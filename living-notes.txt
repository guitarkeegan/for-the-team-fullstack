# Report

I started by taking a look at the requirements and the dataset provided. Then, tried to make some early decisions on tech stack and architecture. 


Write a SQL query that can calculate team win-loss records, sorted by win percentage (defined as wins divided by games played)
Final table should include team name, games played, wins, losses, win percentage

SQL

SELECT 
    t.teamName,
    COUNT(g.game_id) AS games_played,
    SUM(CASE 
            WHEN (g.home_id = t.teamId AND g.home_score > g.away_score) 
              OR (g.away_id = t.teamId AND g.away_score > g.home_score) 
            THEN 1 
            ELSE 0 
        END) AS wins,
    SUM(CASE 
            WHEN (g.home_id = t.teamId AND g.home_score < g.away_score) 
              OR (g.away_id = t.teamId AND g.away_score < g.home_score) 
            THEN 1 
            ELSE 0 
        END) AS losses,
    ROUND(SUM(CASE 
                WHEN (g.home_id = t.teamId AND g.home_score > g.away_score) 
                  OR (g.away_id = t.teamId AND g.away_score > g.home_score) 
                THEN 1 
                ELSE 0 
            END) / CAST(COUNT(g.game_id) AS DECIMAL), 2) AS win_percentage
FROM 
    game_schedule g
JOIN 
    team t 
ON 
    g.home_id = t.teamId OR g.away_id = t.teamId
GROUP BY 
    t.teamName
ORDER BY 
    win_percentage DESC;


--- version 2

WITH team_games AS (
    -- Get home games
    SELECT
        g.game_id,
        t.team_id,
        t.team_name,
        1 AS games_played,
        CASE WHEN g.home_score > g.away_score THEN 1 ELSE 0 END AS wins,
        CASE WHEN g.home_score < g.away_score THEN 1 ELSE 0 END AS losses
    FROM game_schedule g
    JOIN teams t ON t.team_id = g.home_id

    UNION ALL

    -- Get away games
    SELECT
        g.game_id,
        t.team_id,
        t.team_name,
        1 AS games_played,
        CASE WHEN g.away_score > g.home_score THEN 1 ELSE 0 END AS wins,
        CASE WHEN g.away_score < g.home_score THEN 1 ELSE 0 END AS losses
    FROM game_schedule g
    JOIN teams t ON t.team_id = g.away_id
)

SELECT
    tg.team_name,
    SUM(tg.games_played) AS games_played,
    SUM(tg.wins) AS wins,
    SUM(tg.losses) AS losses,
    ROUND(SUM(tg.wins)::NUMERIC / NULLIF(SUM(tg.games_played), 0), 3) AS win_percentage
FROM team_games tg
GROUP BY tg.team_id, tg.team_name
ORDER BY win_percentage DESC, tg.team_name;

-- add pagination --

-- ... [the previous query]
ORDER BY win_percentage DESC, tg.team_name
LIMIT 50 OFFSET 0;  -- First page (teams 1-50)


--- add rank by num of games played within a given month ---

-- Replace ':month' with the desired month in 'YYYY-MM' format, e.g., '2024-01' for January 2024
WITH month_games AS (
    SELECT
        g.game_id,
        g.home_id,
        g.away_id,
        g.game_date
    FROM
        game_schedule g
    WHERE
        TO_CHAR(g.game_date, 'YYYY-MM') = :month
)

SELECT
    t.team_name,
    COUNT(*) AS total_games,
    SUM(CASE WHEN t.team_id = mg.home_id THEN 1 ELSE 0 END) AS home_games,
    SUM(CASE WHEN t.team_id = mg.away_id THEN 1 ELSE 0 END) AS away_games
FROM
    teams t
JOIN
    month_games mg ON t.team_id = mg.home_id OR t.team_id = mg.away_id
GROUP BY
    t.team_id, t.team_name
ORDER BY
    total_games DESC,
    t.team_name;

--- version 2 includes the info from the first table as well as order game played in month ---
-- Replace ':month' with the desired month in 'YYYY-MM' format, e.g., '2024-01' for January 2024

WITH team_games AS (
    -- Home games
    SELECT
        g.game_id,
        t.team_id,
        t.team_name,
        1 AS games_played,
        CASE WHEN g.home_score > g.away_score THEN 1 ELSE 0 END AS wins,
        CASE WHEN g.home_score < g.away_score THEN 1 ELSE 0 END AS losses,
        -- Monthly statistics using date range
        CASE WHEN g.game_date >= TO_DATE(:month, 'YYYY-MM') 
              AND g.game_date < (TO_DATE(:month, 'YYYY-MM') + INTERVAL '1 month') THEN 1 ELSE 0 END AS games_played_in_month,
        CASE WHEN g.game_date >= TO_DATE(:month, 'YYYY-MM') 
              AND g.game_date < (TO_DATE(:month, 'YYYY-MM') + INTERVAL '1 month') THEN 1 ELSE 0 END AS home_games_in_month,
        0 AS away_games_in_month
    FROM game_schedule g
    JOIN teams t ON t.team_id = g.home_id

    UNION ALL

    -- Away games
    SELECT
        g.game_id,
        t.team_id,
        t.team_name,
        1 AS games_played,
        CASE WHEN g.away_score > g.home_score THEN 1 ELSE 0 END AS wins,
        CASE WHEN g.away_score < g.home_score THEN 1 ELSE 0 END AS losses,
        -- Monthly statistics using date range
        CASE WHEN g.game_date >= TO_DATE(:month, 'YYYY-MM') 
              AND g.game_date < (TO_DATE(:month, 'YYYY-MM') + INTERVAL '1 month') THEN 1 ELSE 0 END AS games_played_in_month,
        0 AS home_games_in_month,
        CASE WHEN g.game_date >= TO_DATE(:month, 'YYYY-MM') 
              AND g.game_date < (TO_DATE(:month, 'YYYY-MM') + INTERVAL '1 month') THEN 1 ELSE 0 END AS away_games_in_month
    FROM game_schedule g
    JOIN teams t ON t.team_id = g.away_id
)

SELECT
    tg.team_name,
    SUM(tg.games_played) AS games_played,
    SUM(tg.wins) AS wins,
    SUM(tg.losses) AS losses,
    ROUND(SUM(tg.wins)::NUMERIC / NULLIF(SUM(tg.games_played), 0), 3) AS win_percentage,
    SUM(tg.games_played_in_month) AS games_played_in_month,
    SUM(tg.home_games_in_month) AS home_games_in_month,
    SUM(tg.away_games_in_month) AS away_games_in_month
FROM team_games tg
GROUP BY tg.team_id, tg.team_name
ORDER BY games_played_in_month DESC, tg.team_name;


---- Schedule SQL Queries ----

---- rank teams by b2b, and include home-home, and away-away data
WITH team_games AS (
    SELECT
        t.team_id,
        t.team_name,
        g.game_id,
        DATE(g.game_date) AS game_date,  -- Convert to DATE to remove time component
        CASE WHEN g.home_id = t.team_id THEN 'home' ELSE 'away' END AS location
    FROM
        teams t
    JOIN
        game_schedule g ON t.team_id = g.home_id OR t.team_id = g.away_id
),
team_games_with_lag AS (
    SELECT
        tg.*,
        LAG(game_date) OVER (PARTITION BY team_id ORDER BY game_date) AS prev_game_date,
        LAG(location) OVER (PARTITION BY team_id ORDER BY game_date) AS prev_location
    FROM
        team_games tg
),
back_to_backs AS (
    SELECT
        team_id,
        team_name,
        COUNT(*) FILTER (
            WHERE prev_game_date IS NOT NULL AND game_date - prev_game_date = 1
        ) AS total_back_to_backs,
        COUNT(*) FILTER (
            WHERE prev_game_date IS NOT NULL AND game_date - prev_game_date = 1 AND location = 'home' AND prev_location = 'home'
        ) AS home_home_b2b,
        COUNT(*) FILTER (
            WHERE prev_game_date IS NOT NULL AND game_date - prev_game_date = 1 AND location = 'away' AND prev_location = 'away'
        ) AS away_away_b2b
    FROM
        team_games_with_lag
    GROUP BY
        team_id,
        team_name
)

SELECT
    team_name,
    total_back_to_backs,
    home_home_b2b,
    away_away_b2b
FROM
    back_to_backs
ORDER BY
    total_back_to_backs DESC,
    team_name;

---- variation with home-away and away-home ----

WITH team_games AS (
    SELECT
        t.team_id,
        t.team_name,
        g.game_id,
        DATE(g.game_date) AS game_date,  -- Convert to DATE to remove time component
        CASE WHEN g.home_id = t.team_id THEN 'home' ELSE 'away' END AS location
    FROM
        teams t
    JOIN
        game_schedule g ON t.team_id = g.home_id OR t.team_id = g.away_id
),
team_games_with_lag AS (
    SELECT
        tg.*,
        LAG(game_date) OVER (PARTITION BY team_id ORDER BY game_date) AS prev_game_date,
        LAG(location) OVER (PARTITION BY team_id ORDER BY game_date) AS prev_location
    FROM
        team_games tg
),
back_to_backs AS (
    SELECT
        team_id,
        team_name,
        -- Total back-to-back games
        COUNT(*) FILTER (
            WHERE prev_game_date IS NOT NULL AND game_date - prev_game_date = 1
        ) AS total_back_to_backs,
        -- Home-Home back-to-back games
        COUNT(*) FILTER (
            WHERE prev_game_date IS NOT NULL AND game_date - prev_game_date = 1 AND prev_location = 'home' AND location = 'home'
        ) AS home_home_b2b,
        -- Away-Away back-to-back games
        COUNT(*) FILTER (
            WHERE prev_game_date IS NOT NULL AND game_date - prev_game_date = 1 AND prev_location = 'away' AND location = 'away'
        ) AS away_away_b2b,
        -- Home-Away back-to-back games
        COUNT(*) FILTER (
            WHERE prev_game_date IS NOT NULL AND game_date - prev_game_date = 1 AND prev_location = 'home' AND location = 'away'
        ) AS home_away_b2b,
        -- Away-Home back-to-back games
        COUNT(*) FILTER (
            WHERE prev_game_date IS NOT NULL AND game_date - prev_game_date = 1 AND prev_location = 'away' AND location = 'home'
        ) AS away_home_b2b
    FROM
        team_games_with_lag
    GROUP BY
        team_id,
        team_name
)

SELECT
    team_name,
    total_back_to_backs,
    home_home_b2b,
    away_away_b2b,
    home_away_b2b,
    away_home_b2b
FROM
    back_to_backs
ORDER BY
    total_back_to_backs DESC,
    team_name;


----- most amount of days off between games ----

-- Replace :season_start_date and :season_end_date with the appropriate dates
WITH team_games AS (
    SELECT
        t.team_id,
        t.team_name,
        g.game_id,
        DATE(g.game_date) AS game_date  -- Convert to DATE to remove time component
    FROM
        teams t
    JOIN
        game_schedule g ON t.team_id = g.home_id OR t.team_id = g.away_id
    WHERE
        g.game_date BETWEEN :season_start_date AND :season_end_date
),
team_games_with_lag AS (
    SELECT
        tg.*,
        LAG(game_date) OVER (
            PARTITION BY team_id
            ORDER BY game_date
        ) AS prev_game_date
    FROM
        team_games tg
),
team_rest_days AS (
    SELECT
        team_id,
        team_name,
        prev_game_date,
        game_date,
        (game_date - prev_game_date) AS rest_days
    FROM
        team_games_with_lag
    WHERE
        prev_game_date IS NOT NULL
),
team_max_rest_with_games AS (
    SELECT
        trd.*,
        ROW_NUMBER() OVER (
            PARTITION BY trd.team_id
            ORDER BY trd.rest_days DESC, trd.prev_game_date
        ) AS rn
    FROM
        team_rest_days trd
        JOIN (
            SELECT
                team_id,
                MAX(rest_days) AS max_rest_days
            FROM
                team_rest_days
            GROUP BY
                team_id
        ) mrd ON trd.team_id = mrd.team_id
        AND trd.rest_days = mrd.max_rest_days
)
SELECT
    team_name,
    rest_days AS max_rest_days,
    prev_game_date AS game1_date,
    game_date AS game2_date
FROM
    team_max_rest_with_games
WHERE
    rn = 1
ORDER BY
    max_rest_days DESC,
    team_name;


---- rank by 3-in-4s ----

!!!! returns a ton !!!!

-- Replace :start_date and :end_date with your desired dates in 'YYYY-MM-DD' format
WITH team_games AS (
    SELECT
        t.team_id,
        t.team_name,
        DATE(g.game_date) AS game_date  -- Convert to DATE to remove time component
    FROM
        teams t
    JOIN
        game_schedule g ON t.team_id = g.home_id OR t.team_id = g.away_id
    WHERE
        DATE(g.game_date) BETWEEN :start_date AND :end_date
),
team_games_with_lags AS (
    SELECT
        tg.*,
        LAG(game_date, 1) OVER (
            PARTITION BY team_id
            ORDER BY game_date
        ) AS prev_game_date_1,
        LAG(game_date, 2) OVER (
            PARTITION BY team_id
            ORDER BY game_date
        ) AS prev_game_date_2
    FROM
        team_games tg
),
three_in_four_days AS (
    SELECT
        team_id,
        team_name,
        game_date,
        prev_game_date_1,
        prev_game_date_2,
        (game_date - prev_game_date_2) AS total_days
    FROM
        team_games_with_lags
    WHERE
        prev_game_date_2 IS NOT NULL
),
three_in_four_counts AS (
    SELECT
        team_id,
        team_name,
        COUNT(*) FILTER (
            WHERE total_days <= 4
        ) AS three_in_four_count
    FROM
        three_in_four_days
    GROUP BY
        team_id,
        team_name
)
SELECT
    team_name,
    three_in_four_count
FROM
    three_in_four_counts
ORDER BY
    three_in_four_count DESC,
    team_name;

---- revision with non-overlapping assuming 1st to 5th counts as 4 days... --- 

-- Replace :start_date and :end_date with your desired dates in 'YYYY-MM-DD' format
WITH team_games AS (
    SELECT
        t.team_id,
        t.team_name,
        DATE(g.game_date) AS game_date,
        ROW_NUMBER() OVER (
            PARTITION BY t.team_id
            ORDER BY DATE(g.game_date)
        ) AS rn
    FROM
        teams t
    JOIN
        game_schedule g ON t.team_id = g.home_id OR t.team_id = g.away_id
    WHERE
        DATE(g.game_date) BETWEEN :start_date AND :end_date
),
non_overlapping_sequences AS (
    SELECT
        tg1.team_id,
        tg1.team_name,
        tg1.game_date AS game1_date,
        tg2.game_date AS game2_date,
        tg3.game_date AS game3_date,
        tg3.game_date - tg1.game_date AS total_days
    FROM
        team_games tg1
    JOIN
        team_games tg2 ON tg1.team_id = tg2.team_id AND tg2.rn = tg1.rn + 1
    JOIN
        team_games tg3 ON tg1.team_id = tg3.team_id AND tg3.rn = tg1.rn + 2
    WHERE
        tg3.game_date - tg1.game_date <= 4
),
non_overlapping_counts AS (
    SELECT
        nos.team_id,
        nos.team_name,
        COUNT(*) AS three_in_four_count
    FROM (
        SELECT
            *,
            ROW_NUMBER() OVER (
                PARTITION BY team_id
                ORDER BY game1_date
            ) - ROW_NUMBER() OVER (
                PARTITION BY team_id
                ORDER BY game1_date
            ) / 3 * 3 AS grp
        FROM
            non_overlapping_sequences
    ) nos
    GROUP BY
        nos.team_id,
        nos.team_name
)
SELECT
    team_name,
    three_in_four_count
FROM
    non_overlapping_counts
ORDER BY
    three_in_four_count DESC,
    team_name;

---- revise with assumption that it means 1st to 4th ----

-- Replace :start_date and :end_date with your desired dates in 'YYYY-MM-DD' format
WITH team_games AS (
    SELECT
        t.team_id,
        t.team_name,
        DATE(g.game_date) AS game_date,
        ROW_NUMBER() OVER (
            PARTITION BY t.team_id
            ORDER BY DATE(g.game_date)
        ) AS rn
    FROM
        teams t
    JOIN
        game_schedule g ON t.team_id = g.home_id OR t.team_id = g.away_id
    WHERE
        DATE(g.game_date) BETWEEN :start_date AND :end_date
),
three_in_four_sequences AS (
    SELECT
        tg1.team_id,
        tg1.team_name,
        tg1.game_date AS game1_date,
        tg2.game_date AS game2_date,
        tg3.game_date AS game3_date,
        tg3.game_date - tg1.game_date AS total_days
    FROM
        team_games tg1
    JOIN
        team_games tg2 ON tg1.team_id = tg2.team_id AND tg2.rn = tg1.rn + 1
    JOIN
        team_games tg3 ON tg1.team_id = tg3.team_id AND tg3.rn = tg1.rn + 2
    WHERE
        tg3.game_date - tg1.game_date <= 3  -- Corrected condition
),
non_overlapping_sequences AS (
    SELECT
        *,
        ROW_NUMBER() OVER (
            PARTITION BY team_id
            ORDER BY game1_date
        ) AS seq_num
    FROM
        three_in_four_sequences
),
filtered_sequences AS (
    SELECT
        nos.*
    FROM
        non_overlapping_sequences nos
    LEFT JOIN
        non_overlapping_sequences nos_prev ON nos.team_id = nos_prev.team_id AND nos.seq_num = nos_prev.seq_num + 1
    WHERE
        nos_prev.game3_date IS NULL OR nos.game1_date > nos_prev.game3_date
),
three_in_four_counts AS (
    SELECT
        team_id,
        team_name,
        COUNT(*) AS three_in_four_count
    FROM
        filtered_sequences
    GROUP BY
        team_id,
        team_name
)
SELECT
    team_name,
    three_in_four_count
FROM
    three_in_four_counts
ORDER BY
    three_in_four_count DESC,
    team_name;


------- Lineups Queries --------


---- make a wide table ----

WITH lineup_data AS (
    SELECT
        l.game_id,
        l.team_id,
        l.lineup_num,
        l.period,
        l.time_in,
        l.time_out,
        l.player_id,
        p.first_name,
        p.last_name,
        ROW_NUMBER() OVER (
            PARTITION BY l.game_id, l.team_id, l.lineup_num, l.period, l.time_in, l.time_out
            ORDER BY l.player_id
        ) AS player_num
    FROM
        lineup l
    JOIN
        players p ON l.player_id = p.player_id
)
SELECT
    game_id,
    team_id,
    lineup_num,
    period,
    time_in,
    time_out,
    MAX(CASE WHEN player_num = 1 THEN player_id END) AS player1_id,
    MAX(CASE WHEN player_num = 1 THEN first_name || ' ' || last_name END) AS player1_name,
    MAX(CASE WHEN player_num = 2 THEN player_id END) AS player2_id,
    MAX(CASE WHEN player_num = 2 THEN first_name || ' ' || last_name END) AS player2_name,
    MAX(CASE WHEN player_num = 3 THEN player_id END) AS player3_id,
    MAX(CASE WHEN player_num = 3 THEN first_name || ' ' || last_name END) AS player3_name,
    MAX(CASE WHEN player_num = 4 THEN player_id END) AS player4_id,
    MAX(CASE WHEN player_num = 4 THEN first_name || ' ' || last_name END) AS player4_name,
    MAX(CASE WHEN player_num = 5 THEN player_id END) AS player5_id,
    MAX(CASE WHEN player_num = 5 THEN first_name || ' ' || last_name END) AS player5_name
FROM
    lineup_data
GROUP BY
    game_id,
    team_id,
    lineup_num,
    period,
    time_in,
    time_out
ORDER BY
    game_id,
    team_id,
    lineup_num;
-- with pagination
LIMIT 50 OFFSET 0;

----- including player positions -----


WITH lineup_data AS (
    SELECT
        l.game_id,
        l.team_id,
        l.lineup_num,
        l.period,
        l.time_in,
        l.time_out,
        l.player_id,
        p.first_name,
        p.last_name,
        r.position,
        ROW_NUMBER() OVER (
            PARTITION BY l.game_id, l.team_id, l.lineup_num, l.period, l.time_in, l.time_out
            ORDER BY
                CASE r.position
                    WHEN 'PG' THEN 1
                    WHEN 'SG' THEN 2
                    WHEN 'SF' THEN 3
                    WHEN 'PF' THEN 4
                    WHEN 'C'  THEN 5
                    ELSE 6  -- For any other positions
                END,
                l.player_id  -- Secondary ordering to ensure uniqueness
        ) AS player_num
    FROM
        lineup l
    JOIN
        players p ON l.player_id = p.player_id
    JOIN
        roster r ON l.player_id = r.player_id AND l.team_id = r.team_id
)
SELECT
    game_id,
    team_id,
    lineup_num,
    period,
    time_in,
    time_out,
    -- Player 1
    MAX(CASE WHEN player_num = 1 THEN player_id END) AS player1_id,
    MAX(CASE WHEN player_num = 1 THEN first_name || ' ' || last_name END) AS player1_name,
    MAX(CASE WHEN player_num = 1 THEN position END) AS player1_position,
    -- Player 2
    MAX(CASE WHEN player_num = 2 THEN player_id END) AS player2_id,
    MAX(CASE WHEN player_num = 2 THEN first_name || ' ' || last_name END) AS player2_name,
    MAX(CASE WHEN player_num = 2 THEN position END) AS player2_position,
    -- Player 3
    MAX(CASE WHEN player_num = 3 THEN player_id END) AS player3_id,
    MAX(CASE WHEN player_num = 3 THEN first_name || ' ' || last_name END) AS player3_name,
    MAX(CASE WHEN player_num = 3 THEN position END) AS player3_position,
    -- Player 4
    MAX(CASE WHEN player_num = 4 THEN player_id END) AS player4_id,
    MAX(CASE WHEN player_num = 4 THEN first_name || ' ' || last_name END) AS player4_name,
    MAX(CASE WHEN player_num = 4 THEN position END) AS player4_position,
    -- Player 5
    MAX(CASE WHEN player_num = 5 THEN player_id END) AS player5_id,
    MAX(CASE WHEN player_num = 5 THEN first_name || ' ' || last_name END) AS player5_name,
    MAX(CASE WHEN player_num = 5 THEN position END) AS player5_position
FROM
    lineup_data
GROUP BY
    game_id,
    team_id,
    lineup_num,
    period,
    time_in,
    time_out
ORDER BY
    game_id,
    team_id,
    lineup_num;


-------- player stint time ---------

WITH player_lineups AS (
    SELECT
        l.game_id,
        l.team_id,
        l.period,
        l.player_id,
        l.time_in,
        l.time_out
    FROM
        lineup l
),
player_stints AS (
    SELECT
        pl.*,
        LAG(pl.time_out) OVER (
            PARTITION BY pl.game_id, pl.team_id, pl.player_id, pl.period
            ORDER BY pl.time_in
        ) AS prev_time_out,
        CASE
            WHEN LAG(pl.time_out) OVER (
                PARTITION BY pl.game_id, pl.team_id, pl.player_id, pl.period
                ORDER BY pl.time_in
            ) IS NULL
            OR pl.time_in < LAG(pl.time_out) OVER (
                PARTITION BY pl.game_id, pl.team_id, pl.player_id, pl.period
                ORDER BY pl.time_in
            ) THEN 1
            ELSE 0
        END AS new_stint_flag
    FROM
        player_lineups pl
),
player_stints_with_group AS (
    SELECT
        ps.*,
        SUM(ps.new_stint_flag) OVER (
            PARTITION BY ps.game_id, ps.team_id, ps.player_id, ps.period
            ORDER BY ps.time_in
        ) AS stint_number
    FROM
        player_stints ps
),
stints AS (
    SELECT
        pswg.game_id,
        pswg.team_id,
        pswg.player_id,
        pswg.period,
        pswg.stint_number,
        MAX(pswg.time_in) AS stint_start_time_remaining,
        MIN(pswg.time_out) AS stint_end_time_remaining
    FROM
        player_stints_with_group pswg
    GROUP BY
        pswg.game_id,
        pswg.team_id,
        pswg.player_id,
        pswg.period,
        pswg.stint_number
)
SELECT
    gs.game_date,
    t.team_name AS team,
    opp.team_name AS opponent,
    p.first_name || ' ' || p.last_name AS player_name,
    s.period,
    s.stint_number,
    TO_CHAR(
        (s.stint_start_time_remaining * INTERVAL '1 second'),
        'FMMI:SS'
    ) AS stint_start_time,
    TO_CHAR(
        (s.stint_end_time_remaining * INTERVAL '1 second'),
        'FMMI:SS'
    ) AS stint_end_time
FROM
    stints s
JOIN
    game_schedule gs ON s.game_id = gs.game_id
JOIN
    teams t ON s.team_id = t.team_id
JOIN
    players p ON s.player_id = p.player_id
JOIN
    teams opp ON opp.team_id = CASE
        WHEN s.team_id = gs.home_id THEN gs.away_id
        ELSE gs.home_id
    END
ORDER BY
    gs.game_date,
    t.team_name,
    player_name,
    s.period,
    s.stint_number;
-- to filter add
WHERE
    t.team_name = 'LA Clippers' AND
    p.last_name = 'Anglim'


------ average stint and stint length per game -------

WITH player_lineups AS (
    SELECT
        l.game_id,
        l.team_id,
        l.period,
        l.player_id,
        l.time_in,
        l.time_out
    FROM
        lineup l
),
player_stints AS (
    SELECT
        pl.*,
        LAG(pl.time_out) OVER (
            PARTITION BY pl.game_id, pl.player_id, pl.period
            ORDER BY pl.time_in DESC
        ) AS prev_time_out,
        CASE
            WHEN LAG(pl.time_out) OVER (
                PARTITION BY pl.game_id, pl.player_id, pl.period
                ORDER BY pl.time_in DESC
            ) IS NULL
            OR pl.time_in < LAG(pl.time_out) OVER (
                PARTITION BY pl.game_id, pl.player_id, pl.period
                ORDER BY pl.time_in DESC
            ) THEN 1
            ELSE 0
        END AS new_stint_flag
    FROM
        player_lineups pl
),
player_stints_with_group AS (
    SELECT
        ps.*,
        SUM(ps.new_stint_flag) OVER (
            PARTITION BY ps.game_id, ps.player_id, ps.period
            ORDER BY ps.time_in DESC
        ) AS stint_number
    FROM
        player_stints ps
),
stints AS (
    SELECT
        pswg.game_id,
        pswg.player_id,
        pswg.stint_number,
        MIN(pswg.time_in) AS stint_start_time_remaining,
        MAX(pswg.time_out) AS stint_end_time_remaining
    FROM
        player_stints_with_group pswg
    GROUP BY
        pswg.game_id,
        pswg.player_id,
        pswg.stint_number
),
stint_durations AS (
    SELECT
        s.*,
        (s.stint_start_time_remaining - s.stint_end_time_remaining) AS stint_duration
    FROM
        stints s
),
player_stats AS (
    SELECT
        p.player_id,
        p.first_name || ' ' || p.last_name AS player_name,
        COUNT(DISTINCT sd.game_id) AS total_games,
        COUNT(*) AS total_stints,
        SUM(sd.stint_duration) AS total_stint_duration
    FROM
        stint_durations sd
    JOIN
        players p ON sd.player_id = p.player_id
    GROUP BY
        p.player_id,
        p.first_name,
        p.last_name
)
SELECT
    player_name,
    ROUND((total_stints::numeric / total_games), 2) AS avg_stints_per_game,
    TO_CHAR(
        MAKE_INTERVAL(secs => (total_stint_duration::numeric / total_stints)),
        'MI:SS'
    ) AS avg_stint_length
FROM
    player_stats
ORDER BY
    player_name;
-- for a specific player
WHERE
    p.player_id = <desired_player_id>
-- filter by date range
JOIN game_schedule gs ON pl.game_id = gs.game_id
WHERE
    gs.game_date BETWEEN '2024-01-01' AND '2024-01-31'


--------- stint win losses stats ----------
WITH player_lineups AS (
    SELECT
        l.game_id,
        l.team_id,
        l.period,
        l.player_id,
        l.time_in,
        l.time_out
    FROM
        lineup l
),
player_stints AS (
    SELECT
        pl.*,
        LAG(pl.time_out) OVER (
            PARTITION BY pl.game_id, pl.player_id, pl.period
            ORDER BY pl.time_in DESC
        ) AS prev_time_out,
        CASE
            WHEN LAG(pl.time_out) OVER (
                PARTITION BY pl.game_id, pl.player_id, pl.period
                ORDER BY pl.time_in DESC
            ) IS NULL
            OR pl.time_in < LAG(pl.time_out) OVER (
                PARTITION BY pl.game_id, pl.player_id, pl.period
                ORDER BY pl.time_in DESC
            ) THEN 1
            ELSE 0
        END AS new_stint_flag
    FROM
        player_lineups pl
),
player_stints_with_group AS (
    SELECT
        ps.*,
        SUM(ps.new_stint_flag) OVER (
            PARTITION BY ps.game_id, ps.player_id, ps.period
            ORDER BY ps.time_in DESC
        ) AS stint_number
    FROM
        player_stints ps
),
stints AS (
    SELECT
        pswg.game_id,
        pswg.team_id,
        pswg.player_id,
        pswg.stint_number,
        MAX(pswg.time_in) AS stint_start_time_remaining,
        MIN(pswg.time_out) AS stint_end_time_remaining
    FROM
        player_stints_with_group pswg
    GROUP BY
        pswg.game_id,
        pswg.team_id,
        pswg.player_id,
        pswg.stint_number
),
stint_durations AS (
    SELECT
        s.*,
        (s.stint_start_time_remaining - s.stint_end_time_remaining) AS stint_duration,
        gs.home_id,
        gs.away_id,
        gs.home_score,
        gs.away_score,
        CASE
            WHEN (s.team_id = gs.home_id AND gs.home_score > gs.away_score)
              OR (s.team_id = gs.away_id AND gs.away_score > gs.home_score) THEN 'Win'
            ELSE 'Loss'
        END AS result
    FROM
        stints s
    JOIN
        game_schedule gs ON s.game_id = gs.game_id
),
player_stats AS (
    SELECT
        p.player_id,
        p.first_name || ' ' || p.last_name AS player_name,
        -- Total stats
        COUNT(DISTINCT sd.game_id) AS total_games,
        COUNT(*) AS total_stints,
        SUM(sd.stint_duration) AS total_stint_duration,
        -- Wins stats
        COUNT(DISTINCT CASE WHEN sd.result = 'Win' THEN sd.game_id END) AS total_games_wins,
        COUNT(CASE WHEN sd.result = 'Win' THEN 1 END) AS total_stints_wins,
        SUM(CASE WHEN sd.result = 'Win' THEN sd.stint_duration ELSE 0 END) AS total_stint_duration_wins,
        -- Losses stats
        COUNT(DISTINCT CASE WHEN sd.result = 'Loss' THEN sd.game_id END) AS total_games_losses,
        COUNT(CASE WHEN sd.result = 'Loss' THEN 1 END) AS total_stints_losses,
        SUM(CASE WHEN sd.result = 'Loss' THEN sd.stint_duration ELSE 0 END) AS total_stint_duration_losses
    FROM
        stint_durations sd
    JOIN
        players p ON sd.player_id = p.player_id
    GROUP BY
        p.player_id,
        p.first_name,
        p.last_name
)
SELECT
    player_name,
    -- All games
    total_games,
    ROUND(total_stints::numeric / NULLIF(total_games, 0), 2) AS avg_stints_per_game,
    TO_CHAR(
        MAKE_INTERVAL(secs => total_stint_duration::numeric / NULLIF(total_stints, 0)),
        'MI:SS'
    ) AS avg_stint_length,
    -- Wins
    total_games_wins,
    ROUND(total_stints_wins::numeric / NULLIF(total_games_wins, 0), 2) AS avg_stints_per_game_wins,
    TO_CHAR(
        MAKE_INTERVAL(secs => total_stint_duration_wins::numeric / NULLIF(total_stints_wins, 0)),
        'MI:SS'
    ) AS avg_stint_length_wins,
    -- Losses
    total_games_losses,
    ROUND(total_stints_losses::numeric / NULLIF(total_games_losses, 0), 2) AS avg_stints_per_game_losses,
    TO_CHAR(
        MAKE_INTERVAL(secs => total_stint_duration_losses::numeric / NULLIF(total_stints_losses, 0)),
        'MI:SS'
    ) AS avg_stint_length_losses,
    -- Differences (Wins - Losses)
    ROUND(
        (total_stints_wins::numeric / NULLIF(total_games_wins, 0))
        - (total_stints_losses::numeric / NULLIF(total_games_losses, 0)),
        2
    ) AS avg_stints_per_game_diff,
    TO_CHAR(
        MAKE_INTERVAL(secs =>
            (total_stint_duration_wins::numeric / NULLIF(total_stints_wins, 0))
            - (total_stint_duration_losses::numeric / NULLIF(total_stints_losses, 0))
        ),
        'MI:SS'
    ) AS avg_stint_length_diff
FROM
    player_stats
ORDER BY
    player_name;
-- for a specific player
WHERE
    p.player_id = <desired_player_id>


----- check for lineup duplicates -------
SELECT team_id, player_id, game_id, period, time_in, lineup_num, COUNT(*)
FROM lineup
GROUP BY team_id, player_id, game_id, period, time_in, lineup_num
HAVING COUNT(*) > 1;



----- player averages with claude ------

WITH player_lineups AS (
    SELECT
        l.game_id,
        l.team_id,
        l.period,
        l.player_id,
        l.time_in,
        l.time_out
    FROM
        lineup l
),
player_stats AS (
    SELECT
        p.player_id,
        p.first_name || ' ' || p.last_name AS player_name,
        -- Total stats
        COUNT(DISTINCT sd.game_id) AS total_games,
        COUNT(*) AS total_stints,
        SUM(sd.stint_duration) AS total_stint_duration,
        -- Wins stats
        COUNT(DISTINCT CASE WHEN sd.result = 'Win' THEN sd.game_id END) AS total_games_wins,
        COUNT(CASE WHEN sd.result = 'Win' THEN 1 END) AS total_stints_wins,
        SUM(CASE WHEN sd.result = 'Win' THEN sd.stint_duration ELSE 0 END) AS total_stint_duration_wins,
        -- Losses stats
        COUNT(DISTINCT CASE WHEN sd.result = 'Loss' THEN sd.game_id END) AS total_games_losses,
        COUNT(CASE WHEN sd.result = 'Loss' THEN 1 END) AS total_stints_losses,
        SUM(CASE WHEN sd.result = 'Loss' THEN sd.stint_duration ELSE 0 END) AS total_stint_duration_losses
    FROM
        stint_durations sd
    JOIN
        players p ON sd.player_id = p.player_id
    GROUP BY
        p.player_id,
        p.first_name,
        p.last_name
)
SELECT
    player_name,
    -- All games
    total_games,
    ROUND(total_stints::numeric / NULLIF(total_games, 0), 2) AS avg_stints_per_game,
    TO_CHAR(
        MAKE_INTERVAL(secs => total_stint_duration::numeric / NULLIF(total_stints, 0)),
        'MI:SS'
    ) AS avg_stint_length,
    -- Wins
    total_games_wins,
    ROUND(total_stints_wins::numeric / NULLIF(total_games_wins, 0), 2) AS avg_stints_per_game_wins,
    TO_CHAR(
        MAKE_INTERVAL(secs => total_stint_duration_wins::numeric / NULLIF(total_stints_wins, 0)),
        'MI:SS'
    ) AS avg_stint_length_wins,
    -- Losses
    total_games_losses,
    ROUND(total_stints_losses::numeric / NULLIF(total_games_losses, 0), 2) AS avg_stints_per_game_losses,
    TO_CHAR(
        MAKE_INTERVAL(secs => total_stint_duration_losses::numeric / NULLIF(total_stints_losses, 0)),
        'MI:SS'
    ) AS avg_stint_length_losses,
    -- Differences (Wins - Losses)
    ROUND(
        (total_stints_wins::numeric / NULLIF(total_games_wins, 0))
        - (total_stints_losses::numeric / NULLIF(total_games_losses, 0)),
        2
    ) AS avg_stints_per_game_diff,
    CASE
        WHEN (total_stint_duration_wins::numeric / NULLIF(total_stints_wins, 0)) > (total_stint_duration_losses::numeric / NULLIF(total_stints_losses, 0))
        THEN TO_CHAR(
            MAKE_INTERVAL(secs =>
                (total_stint_duration_wins::numeric / NULLIF(total_stints_wins, 0))
                - (total_stint_duration_losses::numeric / NULLIF(total_stints_losses, 0))
            ),
            'MI:SS'
        )
        ELSE '-' || TO_CHAR(
            MAKE_INTERVAL(secs =>
                (total_stint_duration_losses::numeric / NULLIF(total_stints_losses, 0))
                - (total_stint_duration_wins::numeric / NULLIF(total_stints_wins, 0))
            ),
            'MI:SS'
        )
    END AS avg_stint_length_diff
FROM
    player_stats
ORDER BY
    player_name;